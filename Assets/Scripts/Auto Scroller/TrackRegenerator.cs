using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class TrackRegenerator : MonoBehaviour
{
    private GameObject trackPrefab; // Prefab to instantiate
    public Transform player; // Reference to the player's transform
    public float regenerationDistance = 50f; // Distance to the end of the track for regeneration
    private List<GameObject> trackList = new List<GameObject>(); // List to keep track of generated tracks
    private Transform lastCheckpoint; // Reference to the last checkpoint

    public TrackAndBarrierMeshGenerator trackAndBarrierMeshGenerator;
    public float startDelay = 2f; // Delay before starting

    void Start()
    {
        StartCoroutine(DelayedStart());
    }

    IEnumerator DelayedStart()
    {
        yield return new WaitForSeconds(startDelay); // Delay execution

        // First track is generated by the TrackAndBarrierMeshGenerator
        trackPrefab = trackAndBarrierMeshGenerator.returnTrackWithBarrier();

        if (trackPrefab == null)
        {
            Debug.LogError("Initial track is null. Ensure that returnTrackWithBarrier() is returning a valid track.");
            yield break;
        }

        trackList.Add(trackPrefab); // Add the initial track to the list
        UpdateLastCheckpoint(); // Set the last checkpoint from the initial track
    }

    void Update()
    {
        CheckAndRegenerateTrack();
    }

    void GenerateNewTrack(Vector3 position, Quaternion rotation)
    {
        GameObject newTrack = Instantiate(trackPrefab, position, rotation);

        // Find Checkpoint_0 in the newly instantiated track
        Transform checkpoint0 = newTrack.transform.Find("Checkpoint_0");

        if (checkpoint0 == null)
        {
            Debug.LogError("Checkpoint_0 is missing in the new track!");
            return;
        }

        if (lastCheckpoint != null)
        {
            // Align Checkpoint_0 with the last checkpoint's position and rotation
            Vector3 offset = checkpoint0.position - newTrack.transform.position;
            newTrack.transform.position = lastCheckpoint.position - offset;
            newTrack.transform.rotation = lastCheckpoint.rotation;
        }

        // Update the track list and trackPrefab reference
        trackList.Add(newTrack);
        trackPrefab = newTrack; // Reassign trackPrefab to the newly created track

        if (trackList.Count > 4)
        {
            // Delete the oldest track to maintain a list of 4
            Destroy(trackList[0]);
            trackList.RemoveAt(0);
        }

        // Update the last checkpoint reference for the next track generation
        UpdateLastCheckpoint();
    }

    void UpdateLastCheckpoint()
    {
        if (trackList.Count == 0)
        {
            Debug.LogError("Track list is empty in UpdateLastCheckpoint!");
            return;
        }

        // Find the last checkpoint in the most recent track
        GameObject latestTrack = trackList[trackList.Count - 1];
        Transform checkpointsContainer = latestTrack.transform;
        lastCheckpoint = null;
        int highestIndex = -1;

        foreach (Transform child in checkpointsContainer)
        {
            if (child.name.StartsWith("Checkpoint_"))
            {
                string indexString = child.name.Replace("Checkpoint_", "");
                if (int.TryParse(indexString, out int index))
                {
                    if (index > highestIndex)
                    {
                        highestIndex = index;
                        lastCheckpoint = child;
                    }
                }
            }
        }

        if (lastCheckpoint == null)
        {
            Debug.LogError("No checkpoint found in the current track!");
        }
        else
        {
            Debug.Log("Updated lastCheckpoint to: " + lastCheckpoint.name);
        }
    }

    void CheckAndRegenerateTrack()
    {
        if (lastCheckpoint != null)
        {
            float distanceToLastCheckpoint = Vector3.Distance(player.position, lastCheckpoint.position);

            if (distanceToLastCheckpoint < regenerationDistance)
            {
                Vector3 newTrackPosition = lastCheckpoint.position + lastCheckpoint.forward * 10f;
                GenerateNewTrack(newTrackPosition, lastCheckpoint.rotation);
            }
        }
    }
}
